package entities

import (
	"encoding/json"
	"fmt"
	"log"
)

// Request user params shape to be stored in Database
// Composed with entities.entity
type Request struct {
	// entity access to generic methods
	*entity
	// ID generated by Couchdb value
	ID string `json:"_id"`
	// Rev generated by Couchdb value
	Rev   string `json:"_rev"`
	// Int1 Int1 the first int which multiples will be replaced by Str1
	Int1  uint64 `json:"int1"`
	// Int2 Int2 the second int which multiples will be replaced by Str2
	Int2  uint64 `json:"int2"`
	// Limit Limit the greatest int on which to compute FizzBuzz algortihm
	Limit uint64 `json:"limit"`
	// Str1 Str1 the string to replace multiples of Int1
	Str1  string `json:"str1"`
	// Str2 Str2 the string to replace multiples of Int2
	Str2  string `json:"str2"`
}

// databaseName name of the couchdb database for this entity
const databaseName = "requests"

// Save store entity in CouchDb
func (r *Request) Save() error {
	jsonData, err := json.Marshal(map[string]interface{}{
		"int1" : r.Int1,
		"int2" : r.Int2,
		"limit": r.Limit,
		"str1" : r.Str1,
		"str2" : r.Str2,
	})

	if err != nil {
		return err
	}

	return r.postData(databaseName, jsonData)
}

// FindMostAskedRequest returns the most requested parameters for FizzBuzz
func (r Request) FindMostAskedRequest() (*Request, *int, error) {
	raw, err := r.getData(databaseName, "/_all_docs?include_docs=true")
	if err != nil {
		log.Println(err)
		return nil, nil, err
	}

	var requests struct{
		TotalRows int `json:"total_rows"`
		Offset int `json:"offset"`
		Rows []struct{
			ID  string `json:"id"`
			Key string `json:"key"`
			Value struct{
				rev string
			}
			Doc *Request `json:"doc"`
		} `json:"rows"`
	}

	err = json.Unmarshal(*raw, &requests)

	if err != nil {
		log.Println(err)
		return nil, nil, err
	}

	mostAsked := &Request{}
	maxOccurence := 0

	var grouped []struct {
		request *Request
		count   int
		hash    string
	}

	for _, row := range requests.Rows {
		doc := row.Doc
		docHash := fmt.Sprintf("%d%d%d%s%s", doc.Int1, doc.Int2, doc.Limit, doc.Str1, doc.Str2)

		docExistsInGroup := false
		for i, gr := range grouped {
			grHash := fmt.Sprintf("%d%d%d%s%s", gr.request.Int1, gr.request.Int2, gr.request.Limit, gr.request.Str1, gr.request.Str2)

			if docHash == grHash {
				grouped[i].count++
				if grouped[i].count > maxOccurence {
					mostAsked.Int1  = doc.Int1
					mostAsked.Int2  = doc.Int2
					mostAsked.Limit = doc.Limit
					mostAsked.Str1  = doc.Str1
					mostAsked.Str2  = doc.Str2
				}
				maxOccurence = grouped[i].count
				docExistsInGroup = true
				break
			}
		}

		if !docExistsInGroup {
			grouped = append(grouped, struct {
				request *Request
				count   int
				hash    string
			}{request: doc, count: 1, hash: docHash})
		}
	}

	return mostAsked, &maxOccurence, nil
}

// NewRequest creates a new instance of Request without ID and Rev
func NewRequest(int1 uint64, int2 uint64, limit uint64, str1 string, str2 string) Request {
	return Request{
		Int1:   int1,
		Int2:   int2,
		Limit:  limit,
		Str1:   str1,
		Str2:   str2,
	}
}

// CreateDatabaseIfNotExists see entity.createDatabaseIfNotExists
func (r Request) CreateDatabaseIfNotExists() error {
	return r.createDatabaseIfNotExists(databaseName)
}
